nth_field() {
  awk "{print \$$1}"
}

svn_remove_unversioned() {
  svn st | grep -e "^\?" | nth_field 2 | xargs rm -rf
}

svn_list_siblings() {
  local base siblings sibling
  base=`svn info | grep URL | nth_field 2 | xargs dirname`
  siblings=`svn ls ${base}`
  for sibling in ${siblings}; do
    echo ${base}/${sibling}
  done
}

svn_integrate_branch() {
  local low_rev high_rev message
  low_rev=`svn log -q --stop-on-copy "$1" | ruby -e "puts STDIN.read.scan(/r(\d+)/).last"`
  high_rev=`svn info "$1" | ruby -e "puts STDIN.read.match(/Revision: (\d+)/)[1]"`

  svn merge --non-interactive --ignore-ancestry -r${low_rev}:${high_rev} "$1"

  conflicts=`svn st | ruby -e 'puts STDIN.read.scan(/^\s*C\s+(.*)/).join("\n")' | awk '{print "  "$0}'`
  cat > svn-commit.tmp <<EOS
Integrating $1:

svn merge --ignore-ancestry -r${low_rev}:${high_rev} "$1"

Conflicts on:
$conflicts

Rally task: N/A
QC ticket: N/A
New features: None
Modified features: None
Pages affected: None

EOS

  svn log -r${low_rev}:${high_rev} "$1" | awk '{print "  "$0}' >> svn-commit.tmp
  svn ci -F svn-commit.tmp
}

to_iso_time() {
  while [ -n "$1" ]; do
    ruby -e "require 'time'; puts Time.at($1 / 1000).utc.iso8601"
    shift
  done
}

to_tvlistings_query() {
  ruby <<EOS
    %w(time cgi uri).each { |l| require l }
    query = CGI.parse(URI.parse("$1").query)
    puts "http://eko.dev.cim.comcast.net/cimdata/tv/lineups/tms-@HEADEND_TOKEN@/programs/@START_TIME_TOKEN@/PT@DURATION_TOKEN@m?tvgd=true&vcn=@VCN_TOKEN@&tz=UTC".
         gsub('@HEADEND_TOKEN@', query['headend'].first).
         gsub('@START_TIME_TOKEN@', URI.escape(Time.at(query['startTime'].first.to_i / 1000).utc.iso8601, Regexp.new("[^#{URI::PATTERN::UNRESERVED}]"))).
         gsub('@DURATION_TOKEN@', ((query['endTime'].first.to_i - query['startTime'].first.to_i) / 60000).to_s).
         gsub('@VCN_TOKEN@', query['vcn'].first.to_i.to_s)
EOS
}

tvlistings_check() {
  echo `to_tvlistings_query "$1"`
  to_tvlistings_query "$1" | xargs curl | tidy -xml -i
}

flike() {
  local search path
  if [ -z "$2" ]; then
    search="$1"
    path=.
  else
    search="$2"
    path="$1"
  fi
  find "${path}" -iname "*${search}*"
}

..() {
  local times
  times=$(echo $1 | wc -c)
  for ((i = 1; i < $times ; i++)); do
    cd ..
  done
}